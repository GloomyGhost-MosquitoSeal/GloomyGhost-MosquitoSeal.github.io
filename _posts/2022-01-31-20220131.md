---
layout: post
title: "使用 LicheeRV 86 Panel 实现 RGB 与 SPI 双屏显示"
tags: ["Tina", "Linux", "LicheeRV"]
---

Tina 提供了2种 SPI TFT 显示屏的驱动方式。第一种是官方推荐的 `fbdev` 方式，使用 `Framebuffer implementaion without display hardware of AW` 进行 SPI屏幕的驱动。另外一种是使用 `fbtft` 进行 SPI 屏幕驱动。 `fbdev` 方式由于 `pinctrl` 在新内核中调用方式出现修改，所以暂时无法使用。修改难度较大。`fbtft` 虽然官方wiki表明不建议在 Linux 5.4 中使用，但是其实也是可以使用的，只需要修改一下 GPIO 的注册方式就行。

### 先驱动 SPI 屏幕

这里驱动的屏幕所选择的是 ST7789V SPI

#### 修改 FBTFT 驱动

进入 `tina-d1-open/lichee/linux-5.4/drivers/staging/fbtft` 找到 `fbtft-core.c` 

首先加入将要使用到的头文件

```c
#include <linux/gpio.h>
#include <linux/of_gpio.h>
```

然后找到 `static int fbtft_request_one_gpio()` 函数，将已经弃用的端口绑定方法改为以下内容

```c
static int fbtft_request_one_gpio(struct fbtft_par *par,
                  const char *name, int index,
                  struct gpio_desc **gpiop)
{
    struct device *dev = par->info->device;
    struct device_node *node = dev->of_node;
    int gpio, flags, ret = 0;
    enum of_gpio_flags of_flags;

    if (of_find_property(node, name, NULL)) {
        gpio = of_get_named_gpio_flags(node, name, index, &of_flags);
        if (gpio == -ENOENT)
            return 0;
        if (gpio == -EPROBE_DEFER)
            return gpio;
        if (gpio < 0) {
            dev_err(dev,
                "failed to get '%s' from DT\n", name);
            return gpio;
        }
        flags = (of_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW :
                            GPIOF_OUT_INIT_HIGH;
        ret = devm_gpio_request_one(dev, gpio, flags,
                        dev->driver->name);
        if (ret) {
            dev_err(dev,
                "gpio_request_one('%s'=%d) failed with %d\n",
                name, gpio, ret);
            return ret;
        }

        *gpiop = gpio_to_desc(gpio);
        fbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, "%s: '%s' = GPIO%d\n",
                            __func__, name, gpio);
    }

    return ret;
}
```

找到 `static void fbtft_reset()` 函数，将 RST 信号最后拉高

```c
static void fbtft_reset(struct fbtft_par *par)
{
    if (!par->gpio.reset)
        return;
    fbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);
    gpiod_set_value_cansleep(par->gpio.reset, 1);
    msleep(10);
    gpiod_set_value_cansleep(par->gpio.reset, 0);
    msleep(200);
    gpiod_set_value_cansleep(par->gpio.reset, 1);
    msleep(10);
}
```

找到 `static void fbtft_set_addr_win()` 函数，添加地址偏移。否则会出现下图部分雪花屏现象。

![image-20220130233626284](D:\Github\YuzukiTsuru.GitHub.io\assets\post\2022-01-31-20220131\image-20220130233626284.png)

```c
static void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe,
			       int ye)
{
	switch(par->info->var.rotate)
	{
		case   0: xs+=53;xe+=53;ys+=40;ye+=40;
				 break;
		case  90: xs+=40;xe+=40;ys+=53;ye+=53;
				 break;
		case 180: xs+=53;xe+=53;ys+=40;ye+=40;
				 break;
		case 270: xs+=40;xe+=40;ys+=53;ye+=53;
				 break;
		default :
				 break;
	}

	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
		  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);

	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
		  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);

	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
}
```

找到 `fb_st7789v.c`，参照STM32的初始化函数对初始化部分进行修改。

```c
static int init_display(struct fbtft_par *par)
{
    par->fbtftops.reset(par);
    mdelay(50);
    write_reg(par,0x36,0x00);
    write_reg(par,0x3A,0x05);
    write_reg(par,0xB2,0x0C,0x0C,0x00,0x33,0x33);
    write_reg(par,0xB7,0x35);
    write_reg(par,0xBB,0x19);
    write_reg(par,0xC0,0x2C);
    write_reg(par,0xC2,0x01);
    write_reg(par,0xC3,0x12);
    write_reg(par,0xC4,0x20);
    write_reg(par,0xC6,0x0F);
    write_reg(par,0xD0,0xA4,0xA1);
    write_reg(par,0xE0,0xD0,0x04,0x0D,0x11,0x13,0x2B,0x3F,0x54,0x4C,0x18,0x0D,0x0B,0x1F,0x23);
    write_reg(par,0xE1,0xD0,0x04,0x0C,0x11,0x13,0x2C,0x3F,0x44,0x51,0x2F,0x1F,0x1F,0x20,0x23);
    write_reg(par,0x21);
    write_reg(par,0x11);
    mdelay(50);
    write_reg(par,0x29);
    mdelay(200);
    return 0;
}
```

将屏幕大小配置为屏幕实际大小

```c
static struct fbtft_display display = {
	.regwidth = 8,
	.width = 135,
	.height = 240,
	.gamma_num = 2,
	.gamma_len = 14,
	.gamma = DEFAULT_GAMMA,
	.fbtftops = {
		.init_display = init_display,
		.set_var = set_var,
		.set_gamma = set_gamma,
		.blank = blank,
	},
};
```

#### 设备树修改

首先找到 `pio` 节点，添加 SPI0所用引脚

```css
spi0_pins_a: spi0@0 {
	pins = "PC2", "PC4";
	function = "spi0";
	drive-strength = <10>;
};

spi0_pins_b: spi0@1 {
	pins = "PC3";
	function = "spi0";
	drive-strength = <10>;
	bias-pull-up;
};
```

然后找到 SPI0 节点，添加屏幕使用的设备树。使用 `pinctrl-0` 将 `pio` 中

```css
&spi0 {
	clock-frequency = <100000000>;
	pinctrl-0 = <&spi0_pins_a &spi0_pins_b>;
	status = "okay";
    
    st7789v@0 {
    	status = "okay";
    	compatible = "sitronix,st7789v";
        reg = <0>;
        spi-max-frequency = <32000000>;
        rotate = <90>;
        rgb;
        fps = <30>;
        buswidth = <8>;
		reset = <&pio PC 6 GPIO_ACTIVE_LOW>;
	    dc = <&pio PC 5 GPIO_ACTIVE_LOW>;
		led = <&pio PD 18 GPIO_ACTIVE_HIGH>;
        debug = <1>;
    };
};
```

